#include "tim_uuid.h"

#include "tim_endian.h"

#include <random>
#include <limits>

#include <cstring>


template<typename Integral>
void tim_to_hex(char *&dst, Integral value)
{
    static const char digits[] = "0123456789abcdef";

    value = tim::to_be(value);

    const char* p = reinterpret_cast<const char *>(&value);

    for (unsigned int i = 0; i < sizeof(Integral); ++i, dst += 2)
    {
        unsigned int j = (p[i] >> 4) & 0xf;
        dst[0] = digits[j];
        j = p[i] & 0xf;
        dst[1] = digits[j];
    }
}

template<typename Integral>
bool tim_from_hex(const char *&src, Integral &value)
{
    value = 0;

    for (unsigned int i = 0; i < sizeof(Integral) * 2; ++i)
    {
        int ch = *src++;
        int tmp;
        if (ch >= '0' && ch <= '9')
            tmp = ch - '0';
        else if (ch >= 'a' && ch <= 'f')
            tmp = ch - 'a' + 10;
        else if (ch >= 'A' && ch <= 'F')
            tmp = ch - 'A' + 10;
        else
            return false;

        value = value * 16 + tmp;
    }

    return true;
}

void tim_uuid_to_hex(char *&dst, const unsigned int &d1, const unsigned short &d2, const unsigned short &d3,
                     const unsigned char (&d4)[8], const bool curly_brackets = true)
{
    if (curly_brackets)
        *dst++ = '{';

    tim_to_hex(dst, d1);
    *dst++ = '-';
    tim_to_hex(dst, d2);
    *dst++ = '-';
    tim_to_hex(dst, d3);
    *dst++ = '-';
    for (int i = 0; i < 2; i++)
        tim_to_hex(dst, d4[i]);
    *dst++ = '-';
    for (int i = 2; i < 8; i++)
        tim_to_hex(dst, d4[i]);

    *dst = curly_brackets ? '}' : 0;
}

void tim_uuid_to_compact_hex(char *&dst,
                             const unsigned int &d1, const unsigned short &d2,
                             const unsigned short &d3, const unsigned char (&d4)[8])
{
    tim_to_hex(dst, d1);
    tim_to_hex(dst, d2);
    tim_to_hex(dst, d3);
    for (int i = 0; i < 2; i++)
        tim_to_hex(dst, d4[i]);
    for (int i = 2; i < 8; i++)
        tim_to_hex(dst, d4[i]);
    *dst = 0;
}

bool tim_uuid_from_hex(const char *&src,
                       unsigned int &d1, unsigned short &d2,
                       unsigned short &d3, unsigned char (&d4)[8])
{
    if (*src == '{')
        src++;
    if (!tim_from_hex(src, d1)
            || *src++ != '-'
            || !tim_from_hex(src, d2)
            || *src++ != '-'
            || !tim_from_hex(src, d3)
            || *src++ != '-'
            || !tim_from_hex(src, d4[0])
            || !tim_from_hex(src, d4[1])
            || *src++ != '-'
            || !tim_from_hex(src, d4[2])
            || !tim_from_hex(src, d4[3])
            || !tim_from_hex(src, d4[4])
            || !tim_from_hex(src, d4[5])
            || !tim_from_hex(src, d4[6])
            || !tim_from_hex(src, d4[7]))
        return false;

    return true;
}

/** \class tim::uuid

    \brief The tim::uuid class stores a Universally Unique Identifier (UUID).

    Using Universally Unique IDentifiers (UUID) is a
    standard way to uniquely identify entities in a distributed
    computing environment. A UUID is a 16-byte (128-bit) number
    generated by some algorithm that is meant to guarantee that the
    UUID will be unique in the distributed computing environment where
    it is used. The acronym GUID is often used instead, Globally
    Unique IDentifiers, but it refers to the same thing.

    Variant field
    -------------

    Actually, the GUID is one variant of UUID. Multiple variants
    are in use. Each UUID contains a bit field that specifies which
    type (variant) of UUID it is. Call variant() to discover which
    type of UUID an instance of tim::uuid contains. It extracts the three
    most signifcant bits of byte 8 of the 16 bytes. In tim::uuid, byte 8
    is tim::uuid::data4[0]. If you create instances of tim::uuid using the
    constructor that accepts all the numeric values as parameters, use
    the following table to set the three most significant bits of
    parameter b1, which becomes tim::uuid::data4[0] and contains
    the variant field in its three most significant bits. In the
    table, 'x' means don't care.

    msb0 | msb1 | msb2 | Variant
    :---:|:----:|:----:|--------
    0    | x    | x    | Ncs (Network Computing System)
    1    | 0    | x    | Dce (Distributed Computing Environment)
    1    | 1    | 0    | Microsoft (GUID)
    1    | 1    | 1    | Reserved for future expansion

    version field
    -------------

    If variant() returns tim::uuid::Dce, the UUID also contains a
    version field in the four most significant bits of
    tim::uuid::data3, and you can call version() to discover which
    version your tim::uuid contains. If you create instances of tim::uuid
    using the constructor that accepts all the numeric values as
    parameters, use the following table to set the four most
    significant bits of parameter w2, which becomes
    tim::uuid::data3 and contains the version field in its four most
    significant bits.

    msb0 | msb1 | msb2 | msb3 | version
    :---:|:----:|:----:|:----:|--------
    0    | 0    | 0    | 1    | Time
    0    | 0    | 1    | 0    | Embedded POSIX
    0    | 0    | 1    | 1    | Name
    0    | 1    | 0    | 0    | Random

    The field layouts for the Dce versions listed in the table above
    are specified in the [Network Working Group UUID Specification](http://www.ietf.org/rfc/rfc4122.txt).

    Most platforms provide a tool for generating new UUIDs, e.g. uuidgen
    and guidgen. You can also use create().  UUIDs
    generated by create() are of the random type.  Their
    tim::uuid::version bits are set to tim::uuid::Random, and their
    tim::uuid::Variant bits are set to tim::uuid::Dce. The rest of the UUID is
    composed of random numbers. Theoretically, this means there is a
    small chance that a UUID generated by create() will not be
    unique. But it is
    [a very small chance](http://en.wikipedia.org/wiki/Universally_Unique_Identifier#Random_UUID_probability_of_duplicates).

    UUIDs can be constructed from numeric values or from strings, or
    using the static create() function. They can be converted to a
    string with toString(). UUIDs have a variant() and a version(),
    and null UUIDs return true from empty().
*/

/** Creates the null UUID. to_string() will output the null UUID
    as "{00000000-0000-0000-0000-000000000000}".
*/
tim::uuid::uuid()
    : _valid(true)
    , data1(0)
    , data2(0)
    , data3(0)
    , data4{}
{
}

tim::uuid::uuid(const tim::uuid &other)
    : _valid(other._valid)
    , data1(other.data1)
    , data2(other.data2)
    , data3(other.data3)
    , data4{}
{
    std::memcpy(data4, other.data4, sizeof(data4));
}

/** Creates a UUID with the value specified by the parameters, \a l,
    \a w1, \a w2, \a b1, \a b2, \a b3, \a b4, \a b5, \a b6, \a b7, \a
    b8.
*/
tim::uuid::uuid(unsigned int l, unsigned short w1, unsigned short w2,
               unsigned char b1, unsigned char b2, unsigned char b3, unsigned char b4,
               unsigned char b5, unsigned char b6, unsigned char b7, unsigned char b8)
    : _valid(true)
    , data1(l)
    , data2(w1)
    , data3(w2)
    , data4{}
{
    data4[0] = b1;
    data4[1] = b2;
    data4[2] = b3;
    data4[3] = b4;
    data4[4] = b5;
    data4[5] = b6;
    data4[6] = b7;
    data4[7] = b8;
}

/** Creates a tim::uuid object from the string \a text, which must be
    formatted as five hex fields separated by '-', e.g.,
    "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" where 'x' is a hex
    digit. The curly braces shown here are optional, but it is normal to
    include them. If the conversion fails, a null UUID is created.  See
    to_string() for an explanation of how the five hex fields map to the
    public data members in tim::uuid.

    \sa to_string(), tim::uuid()
*/
tim::uuid::uuid(const std::string &text)
    : _valid(false)
    , data1(0)
    , data2(0)
    , data3(0)
    , data4{}
{
    from_string(text);
}

tim::uuid::uuid(const char *text)
    : _valid(false)
    , data1(0)
    , data2(0)
    , data3(0)
    , data4{}
{
    if (!text)
        return;

    if (!tim_uuid_from_hex(text, data1, data2, data3, data4))
    {
        clear();
        return;
    }

    _valid = true;
}

/** Returns the string representation of this tim::uuid. The string is
    formatted as five hex fields separated by '-' and enclosed in
    curly braces, i.e., "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" where
    'x' is a hex digit.  From left to right, the five hex fields are
    obtained from the four public data members in tim::uuid as follows:

    Field # | Source
    :------:|-------
    1       | data1
    2       | data2
    3       | data3
    4       | data4[0] .. data4[1]
    5       | data4[2] .. data4[7]
*/
std::string tim::uuid::to_string(const format format) const
{
    char buffer[39];
    buffer[38] = 0;

    char *data = buffer;
    switch (format)
    {
        case format::Canonical:
            tim_uuid_to_hex(data, data1, data2, data3, data4, true);
            break;

        case format::NoBrackets:
            tim_uuid_to_hex(data, data1, data2, data3, data4, false);
            break;

        case format::Compact:
            tim_uuid_to_compact_hex(data, data1, data2, data3, data4);
            break;
    }
    return buffer;
}

bool tim::uuid::from_string(const std::string &text)
{
    if (text.length() < 36)
        return false;

    const char *data = text.c_str();

    if (*data == '{' && text.length() < 37)
        return false;

    if (!tim_uuid_from_hex(data, data1, data2, data3, data4))
    {
        clear();
        return false;
    }

    _valid = true;

    return true;
}

/** Returns true if this is the null UUID
    {00000000-0000-0000-0000-000000000000}; otherwise returns false.
*/
bool tim::uuid::is_null() const
{
    return data4[0] == 0 && data4[1] == 0 && data4[2] == 0 && data4[3] == 0 &&
           data4[4] == 0 && data4[5] == 0 && data4[6] == 0 && data4[7] == 0 &&
           data1 == 0 && data2 == 0 && data3 == 0;
}

void tim::uuid::clear()
{
    data1 = 0;
    data2 = 0;
    data3 = 0;
    std::memset(data4, 0, sizeof(data4));
    _valid = true;
}

tim::uuid &tim::uuid::operator=(const tim::uuid &other)
{
    data1 = other.data1;
    data2 = other.data2;
    data3 = other.data3;
    _valid = other._valid;
    std::memcpy(data4, other.data4, sizeof(data4));

    return *this;
}

/** \return true if this tim::uuid and the \a other tim::uuid are identical;
    otherwise returns false.
*/
bool tim::uuid::operator==(const tim::uuid &orig) const
{
    if (data1 != orig.data1
            || data2 != orig.data2
            || data3 != orig.data3)
        return false;

    for(unsigned i = 0; i < 8; ++i)
        if (data4[i] != orig.data4[i])
            return false;

    return true;
}

/** Returns the value in the variant field of the
    UUID. If the return value is tim::uuid::Dce, call uuid_version() to see
    which layout it uses. The null UUID is considered to be of an
    unknown variant.

    \sa uuid_version()
*/
tim::uuid::variant tim::uuid::uuid_variant() const
{
    if (is_null())
        return variant::Unknown;
    // Check the 3 MSB of data4[0].
    if ((data4[0] & 0x80) == 0x00)
        return variant::Ncs;
    else if ((data4[0] & 0xC0) == 0x80)
        return variant::Dce;
    else if ((data4[0] & 0xE0) == 0xC0)
        return variant::Microsoft;
    else if ((data4[0] & 0xE0) == 0xE0)
        return variant::Reserved;
    return variant::Unknown;
}

/** Returns the version field of the UUID, if the
    UUID's variant field is tim::uuid::variant::Dce. Otherwise
    it returns tim::uuid::version::Unknown.

    \sa variant()
*/
tim::uuid::version tim::uuid::uuid_version() const
{
    // Check the 4 MSB of data3
    version ver = (version)(data3 >> 12);
    if (is_null()
            || (uuid_variant() != variant::Dce)
            || ver < version::Time
            || ver > version::Random)
        return version::Unknown;
    return ver;
}


#define ISLESS(f1, f2) if (f1 != f2) return (f1 < f2);

/** Returns true if this tim::uuid has the same variant field
    as the \a other tim::uuid and is lexicographically
    before the \a other tim::uuid. If the \a other tim::uuid has a
    different variant field, the return value is determined by
    comparing the two variants.

    \sa variant()
*/
bool tim::uuid::operator<(const tim::uuid &other) const
{
    if (uuid_variant() != other.uuid_variant())
        return uuid_variant() < other.uuid_variant();

    ISLESS(data1, other.data1);
    ISLESS(data2, other.data2);
    ISLESS(data3, other.data3);
    for (int n = 0; n < 8; ++n)
        ISLESS(data4[n], other.data4[n]);

    return false;
}


#define ISMORE(f1, f2) if (f1 != f2) return (f1 > f2);

/** Returns true if this tim::uuid has the same variant field as the
    \a other tim::uuid and is lexicographically
    after the \a other tim::uuid. If the \a other tim::uuid has a
    different variant field, the return value is determined by
    comparing the two variants.

    \sa variant()
*/
bool tim::uuid::operator>(const tim::uuid &other) const
{
    if (uuid_variant() != other.uuid_variant())
        return uuid_variant() > other.uuid_variant();

    ISMORE(data1, other.data1);
    ISMORE(data2, other.data2);
    ISMORE(data3, other.data3);
    for (int n = 0; n < 8; ++n)
        ISMORE(data4[n], other.data4[n]);

    return false;
}

/** This function returns a new
    UUID with variant tim::uuid::Dce and version tim::uuid::Random.

    \sa variant(), version()
*/

tim::uuid tim::uuid::create()
{
    static std::random_device rd;
    static std::default_random_engine rng(rd());

    tim::uuid result;

    unsigned *data = &(result.data1);

    std::uniform_int_distribution<> dist(0, std::numeric_limits<unsigned>::max());
    *data       = dist(rng);
    *(data + 1) = dist(rng);
    *(data + 2) = dist(rng);
    *(data + 3) = dist(rng);

    result.data4[0] = (result.data4[0] & 0x3F) | 0x80; // UV_DCE
    result.data3 = (result.data3 & 0x0FFF) | 0x4000;   // UV_Random

    return result;
}
